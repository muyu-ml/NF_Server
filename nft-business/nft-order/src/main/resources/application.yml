spring:
  application:
    name: nft-order # 应用名称
  main:
    allow-bean-definition-overriding: true # 允许Bean定义覆盖
  config:
    import: classpath:base.yml,classpath:rpc.yml,classpath:datasource-sharding.yml,classpath:cache.yml,classpath:job.yml,classpath:stream.yml,classpath:seata.yml
  cloud:
    function:
      definition: orderClose;heldCollection # 定义函数
    stream:
      # 配置 binder，设置为rocketmq，并针对不同的生产者和消费做特殊配置
      rocketmq:
        bindings:
          orderClose-out-0: # 生产者配置
            # 设置该消息发送为事务消息，以及事务消息的处理类
            producer:
              producerType: Trans # 事务型生产者
              transactionListener: orderCloseTransactionListener  # 事务监听器
          heldCollection-in-0: # 消费者配置
            # 设置该消息消费机制，只消费特定类型的 tag
            consumer:
              subscription:
                expression: 'ACTIVE' # 订阅的Tag
      bindings:
        heldCollection-in-0: # 输入通道配置
          content-type: application/json
          destination: held-collection-result-topic # RocketMQ主题
          group: held-collection-group # 消费者组
          binder: rocketmq # 使用的binder
        orderClose-out-0:  # 输出通道配置
          content-type: application/json
          destination: order-close-topic
          group: order-group
          binder: rocketmq
        newBuy-in-0: # 另一个输入通道
          content-type: application/json
          destination: new-buy-topic
          group: trade-group
          binder: rocketmq
  shardingsphere:
    rules:
      sharding:
        tables:
          trade_order: # 交易订单表配置
            actual-data-nodes: ds.trade_order_000${0..3} # 实际数据节点，分4张表
            keyGenerateStrategy:  # 主键生成策略
              column: id # 主键列
              keyGeneratorName: snowflake # 使用雪花算法
            table-strategy: # 分表策略
              complex: # 复合分片
                shardingColumns: buyer_id,order_id # 分片列
                shardingAlgorithmName: trade-order-sharding # 分片算法名称
          trade_order_stream:  # 交易订单流水表配置
            actual-data-nodes: ds.trade_order_stream_000${0..3}
            keyGenerateStrategy:
              column: id
              keyGeneratorName: snowflake
            table-strategy:
              complex:
                shardingColumns: buyer_id,order_id
                shardingAlgorithmName: trade-order-sharding
        shardingAlgorithms:
#          t-order-inline:
#            type: INLINE
#            props:
#              algorithm-expression: trade_order_0${Math.abs(buyer_id.hashCode()) % 4}
          trade-order-sharding: # 自定义分片算法
            type: CLASS_BASED
            props:
              algorithmClassName: com.lcl.nft.order.infrastructure.sharding.algorithm.TurboKeyShardingAlgorithm # 自定义算法类
              strategy: complex
              tableCount: 4 # 分表数量
              mainColum: buyer_id  # 主要分片列
        keyGenerators:
          snowflake:  # 雪花算法配置
            type: SNOWFLAKE
        auditors:
          sharding_key_required_auditor: # 分片键审计
            type: DML_SHARDING_CONDITIONS

server:
  port: 9000


seata:
  use-jdk-proxy: true # 使用JDK动态代理
  enable-auto-data-source-proxy: false  # 禁用自动数据源代理